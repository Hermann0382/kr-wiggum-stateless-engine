/**
 * ShiftReportGenerator - TASK-048
 * Generates shift reports summarizing Manager session status
 */
import { randomUUID } from 'node:crypto';
import { writeFile } from 'node:fs/promises';
import { join } from 'node:path';

import type { ShiftReport, SystemStatus } from '../../schemas/index.js';
import { createTelemetryManager, createImplementationPlanManager } from '../../state/index.js';
import type { GuardrailResult } from '../../types/guardrail.types.js';
import type { ManagerSession } from '../../types/index.js';

/**
 * Shift report generation options
 */
export interface ShiftReportOptions {
  basePath: string;
  session: ManagerSession;
  guardrailResult?: GuardrailResult;
  costUsd?: number;
}

/**
 * Shift report generation result
 */
export interface ShiftReportResult {
  report: ShiftReport;
  filePath: string;
  markdown: string;
}

/**
 * Map guardrail status to system status
 */
function mapGuardrailStatus(passed: boolean): SystemStatus {
  return passed ? 'passing' : 'failing';
}

/**
 * Generate executive summary from session data
 */
function generateExecutiveSummary(
  session: ManagerSession,
  guardrailResult: GuardrailResult | undefined
): string {
  const tasksCompleted = session.tasksCompleted.length;
  const tasksAssigned = session.tasksAssigned.length;
  const contextUsed = session.currentContextFill - session.contextFillAtStart;

  const lines: string[] = [];

  // Opening status
  if (tasksCompleted > 0) {
    lines.push(
      `This shift completed ${tasksCompleted} task${tasksCompleted === 1 ? '' : 's'} ` +
        `out of ${tasksAssigned} assigned.`
    );
  } else {
    lines.push('No tasks were completed during this shift.');
  }

  // Context usage
  lines.push(
    `Context usage: Started at ${session.contextFillAtStart}%, ` +
      `ended at ${session.currentContextFill}% (${contextUsed > 0 ? '+' : ''}${contextUsed}% delta).`
  );

  // ADR activity
  if (session.adrsCreated.length > 0) {
    lines.push(
      `Architecture decisions recorded: ${session.adrsCreated.length} ADR${session.adrsCreated.length === 1 ? '' : 's'} created.`
    );
  }

  // Guardrail status
  if (guardrailResult !== undefined) {
    const status = guardrailResult.allPassing ? 'all passing' : 'some failing';
    lines.push(`Build status: ${status}.`);
  }

  // Handoff info
  if (session.handoffFile !== null) {
    lines.push('Handoff document generated for successor Manager.');
  }

  return lines.join(' ');
}

/**
 * Generate markdown report
 */
function generateMarkdown(report: ShiftReport): string {
  const lines: string[] = [];

  lines.push('# Shift Report');
  lines.push('');
  lines.push(`**Session ID:** ${report.session_id}`);
  lines.push(`**Project ID:** ${report.project_id}`);
  lines.push(`**Generated:** ${report.created_at}`);
  lines.push('');

  lines.push('## Executive Summary');
  lines.push('');
  lines.push(report.executive_summary);
  lines.push('');

  lines.push('## Tasks');
  lines.push('');
  lines.push(`- **Completed:** ${report.tasks_completed.length > 0 ? report.tasks_completed.join(', ') : 'None'}`);
  lines.push(`- **Failed:** ${report.tasks_failed.length > 0 ? report.tasks_failed.join(', ') : 'None'}`);
  lines.push(`- **Blocked:** ${report.tasks_blocked.length > 0 ? report.tasks_blocked.join(', ') : 'None'}`);
  lines.push('');

  lines.push('## System Status');
  lines.push('');
  lines.push(`| System | Status |`);
  lines.push(`|--------|--------|`);
  lines.push(`| Compiler | ${report.llvm_status} |`);
  lines.push(`| Tests | ${report.tests_status} |`);
  lines.push(`| Lint | ${report.lint_status} |`);
  lines.push('');

  lines.push('## Context Usage');
  lines.push('');
  lines.push(`- **Start:** ${report.context_fill_at_start}%`);
  lines.push(`- **End:** ${report.context_fill_at_end}%`);
  lines.push(`- **Delta:** ${report.context_fill_at_end - report.context_fill_at_start}%`);
  lines.push('');

  lines.push('## Metrics');
  lines.push('');
  lines.push(`- **Duration:** ${report.duration_minutes} minutes`);
  lines.push(`- **Cost:** $${report.cost_usd.toFixed(2)}`);
  lines.push('');

  if (report.adrs_created.length > 0) {
    lines.push('## ADRs Created');
    lines.push('');
    for (const adr of report.adrs_created) {
      lines.push(`- ${adr}`);
    }
    lines.push('');
  }

  lines.push('---');
  lines.push('');
  lines.push('ðŸ¤– Generated by KR-Wiggum Stateless Engine');

  return lines.join('\n');
}

/**
 * Generate a shift report
 */
export async function generateShiftReport(
  options: ShiftReportOptions
): Promise<ShiftReportResult> {
  const { basePath, session, guardrailResult, costUsd = 0 } = options;

  // Calculate duration
  const now = new Date();
  const durationMs = now.getTime() - session.startedAt.getTime();
  const durationMinutes = Math.round(durationMs / 60000);

  // Determine system statuses
  const llvmStatus: SystemStatus = guardrailResult
    ? mapGuardrailStatus(guardrailResult.typescript.passed)
    : 'unknown';

  const testsStatus: SystemStatus = guardrailResult
    ? mapGuardrailStatus(guardrailResult.tests.passed)
    : 'unknown';

  const lintStatus: SystemStatus = guardrailResult
    ? mapGuardrailStatus(guardrailResult.lint.passed)
    : 'unknown';

  // Get failed/blocked tasks from implementation plan
  const planManager = createImplementationPlanManager(basePath);
  let failedTasks: string[] = [];
  let blockedTasks: string[] = [];

  try {
    const planContent = await planManager.read();
    const parsedTasks = planManager.parseTasks(planContent);

    // Tasks that were assigned but not completed are considered failed
    failedTasks = session.tasksAssigned.filter(
      (taskId) => !session.tasksCompleted.includes(taskId)
    );

    // Tasks that are unchecked and not assigned are blocked/pending
    blockedTasks = parsedTasks
      .filter((t) => !t.checked && !session.tasksAssigned.includes(t.id))
      .map((t) => t.id);
  } catch {
    // Plan may not exist yet
  }

  // Build report
  const report: ShiftReport = {
    id: randomUUID(),
    project_id: session.projectId,
    session_id: session.sessionId,
    executive_summary: generateExecutiveSummary(session, guardrailResult),
    tasks_completed: session.tasksCompleted,
    tasks_failed: failedTasks,
    tasks_blocked: blockedTasks,
    llvm_status: llvmStatus,
    tests_status: testsStatus,
    lint_status: lintStatus,
    context_fill_at_start: session.contextFillAtStart,
    context_fill_at_end: session.currentContextFill,
    duration_minutes: durationMinutes,
    cost_usd: costUsd,
    adrs_created: session.adrsCreated,
    created_at: now.toISOString(),
  };

  // Generate markdown
  const markdown = generateMarkdown(report);

  // Write to file
  const fileName = `shift-report-${session.sessionId.slice(0, 8)}.md`;
  const filePath = join(basePath, '.agent', fileName);
  await writeFile(filePath, markdown, 'utf-8');

  return {
    report,
    filePath,
    markdown,
  };
}

/**
 * Create shift report generator (factory function)
 */
export function createShiftReportGenerator(basePath: string) {
  return {
    generate: (
      session: ManagerSession,
      guardrailResult?: GuardrailResult,
      costUsd?: number
    ) =>
      generateShiftReport({
        basePath,
        session,
        guardrailResult,
        costUsd,
      }),
  };
}
